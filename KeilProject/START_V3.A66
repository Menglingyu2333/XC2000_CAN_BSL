$MODV2                                  ; Define C166v2 core mode
;
;------------------------------------------------------------------------------
;  This file is part of the C166 Compiler package
;  Copyright KEIL ELEKTRONIK GmbH 1993 - 2014
;  Version 5.10
;  *** <<< Use Configuration Wizard in Context Menu >>> ***
;
;------------------------------------------------------------------------------
;  START_V3.A66:  This code is executed after processor reset and provides the
;                 startup sequence for the Infineon XC2xxx and XE16x devices.
;
;  You may add this file to a uVision3 project - in this case it will be 
;  automatically assembled and linked.
;
;  For manual translation of this file use A166 with the following invocation:
;
;     A166 START_V3.A66 SET (model)
;
;     model determines the memory model and can be one of the following:
;         TINY, SMALL, COMPACT, HCOMPACT, MEDIUM, LARGE, HLARGE, XLARGE
;
;  Example:  A166 START_V2.A66 SET (SMALL)
;
;  For manual linkage of the modified START_V3.OBJ file to your application
;  use the following L166 invocation:
;
;     L166 your object file list, START_V3.OBJ controls
;
;------------------------------------------------------------------------------
; Setup model-dependend Assembler controls
$CASE
$IF NOT TINY
$SEGMENTED
$ENDIF

; Settings for ADDRSEL calculation (do not change!)
KB          EQU    0x400     ; define KB constant for CS _SIZE calculation
MB          EQU    0x400*KB  ; define MB as 1024KB
;------------------------------------------------------------------------------
;
; <h>Definitions for System and User Stack
; ========================================
;
; <o>STKSZ: Maximum System Stack Size selection <0x0-0x1000:0x2>
; <i> Defines the system stack space that is used by CALL/RET and PUSH/POP
; <i> instructions.  The system stack space must be adjusted according the actual
; <i> requirements of the application.
SSTSZ   EQU     0x200 
; <o> USTSZ: User Stack Size Definition <0x0-0x4000:0x2>
; <i> Defines the user stack space available for automatics.  This stack space is
; <i> accessed by R0.  The user stack space must be adjusted according the actual
; <i> requirements of the application.
USTSZ   EQU     0x200    ; set User Stack Size to 200H Bytes.
;
; <o> UST1SZ: User Stack Size for local register bank 1 <0x0-0x4000:0x2>
; <i> Defines the user stack space available for the interrupt functions that are
; <i> assigned to the local register bank 1.  Since the compiler cannot copy the R0
; <i> value to local register banks, the user stack must be assign separately.
; <i> If you have no interrupt functions assigned to local register bank 1, you may
; <i> set UST1SZ to 0.
UST1SZ   EQU    0x20     ; set User Stack Size to 20H Bytes.
;
; <o> UST2SZ: User Stack Size for local register bank 2 <0x0-0x4000:0x2>
; <i> Defines the user stack space available for the interrupt functions that are
; <i> assigned to the local register bank 1.  Since the compiler cannot copy the R0
; <i> value to local register banks, the user stack must be assign separately.
;  If you have no interrupt functions assigned to local register bank 2, you may
;  set UST2SZ to 0.
UST2SZ   EQU    0x20     ; set User Stack Size to 20H Bytes.
;
; </h>
; <h>Definitions for Startup Code
; ===============================
;
; <q> CLR_MEMORY: Enable/Disable Memory Zero Initialization of RAM area
; --- <i> Set CLR_MEMORY = 0 to disable memory zero initialization
$SET (CLR_MEMORY = 1)
;
; <q> INIT_VARS: Enable/Disable Variable Initialization
; --- <i> Set INIT_VARS = 0 to disable variable initialization
$SET (INIT_VARS = 1)
;
; <q> DPPUSE:  Allow re-assign of DPP registers 
; --- <i> Set DPPUSE = 0 to reduce the code size of the startup code, if you
;     <i> are not using the L166 DPPUSE directive.
$SET (DPPUSE = 1)
;
; <q> DPP3USE: Use DPP3 register during variable initialization
; --- <i> Set DPP3USE = 0 to disable the usage of DPP3 during initialization of
;     <i> variables.  This option might be required if you write
;     <i> program parts that are reloaded during application 
;     <i> execution and increase code size of the startup code.
$SET (DPP3USE = 1)
;
;</h>
; <h> CPU Configuration
; =====================
;
; <e> Definitions for CPU Configuration Register CPUCON1
; ======================================================
;
;  INIT_CPUCON1: Init CPUCON1 register
; --- <i>Set INIT_CPUCON1 = 1 to initialize the CPUCON1 register
$SET (INIT_CPUCON1 = 0) ; default: do not initialize CPUCON1  
;
; <q> ZCJ: Enable Zero Cycle Jump Function (CPUCON1.0):
_ZCJ     EQU    1       ; 0 = Disable Zero Cycle Jump Function
                        ; 1 = Enable Zero Cycle Jump Function
;
; <q> BP: Enable Branch Prediction Unit (CPUCON1.1):
_BP      EQU    1       ; 0 = Disable Branch Prediction Unit
                        ; 1 = Enable Branch Prediction Unit
;
; <q> INTSCXT: Enable Interruptability of Switch Context Instruction (CPUCON1.2):
_INTSCXT EQU    1       ; 0 = Disable Interruption of SCXT instruction
                        ; 1 = Enable Interruption of SCXT instruction
;
; SGTDIS: Disable Segmentation Control (CPUCON1.3):
$IF TINY
_SGTDIS  EQU    1       ; disable segmented mode for TINY model
$ELSE
_SGTDIS  EQU    0       ; enable segmented mode (Reset Value)
$ENDIF
;
; <o> WDTCTL: Watchdog Timer Control (CPUCON1.4):
; <0=> DISWDT executable until end of EINIT  <1=> DISWDT/ENWDT always executable
_WDTCTL  EQU    0       ; 0 = DISWDT executable until end of EINIT
                        ; 1 = DISWDT/ENWDT always executable
;
; <o> VECSC: Vector Table Scaling Factor (CPUCON1.5 .. CPUCON1.6)
; <0=> 2 words  <1=> 4 words  <2=> 8 words  <3=> 16 words
_VECSC   EQU    0       ; 0 = Space between two vectors is 2 words
                        ; 1 = Space between two vectors is 4 words
                        ; 2 = Space between two vectors is 8 words
                        ; 3 = Space between two vectors is 16 words
;
; </e>
;
; <e> Definitions for CPU Configuration Register CPUCON2
; ======================================================
;
;  INIT_CPUCON2: Init CPUCON2 register
; --- <i>Set INIT_CPUCON2 = 1 to initialize the CPUCON2 register
$SET (INIT_CPUCON2 = 0) ; default: do not initialize CPUCON2  
;
; <q> SL: Enable Short Loop Mode (CPUCON2.0)
_SL       EQU   1       ; 0 = Short Loop mode disabled
                        ; 1 = Short Loop mode enabled
;
; <q> DAID: Disable Atomic Injection Deny (CPUCON2.1)
_DAID  EQU   1          ; 0 = Injection-requests are denied during Atomic 
                        ; 1 = Injection-requests are not denied during Atomic 
;
; <q> RETST: Enable Return Stack (CPUCON2.3)
_RETST    EQU   1       ; 0 = Return Stack disabled
                        ; 1 = Return Stack enabled
;
; <q> OVRUN: Allow Pipeline Bubble Overrun (CPUCON2.4)
_OVRUN    EQU   1       ; 0 = Overrun of Pipeline Bubbles not allowed
                        ; 1 = Overrun of Pipeline Bubbles allowed
;
; <q> LFIC: Linear Follower Instruction Cache (CPUCON2.5)
_LFIC     EQU   1       ; 0 = Zero Cycle Jump Cache disabled
                        ; 1 = Zero Cycle Jump Cache enabled
;
; <q> STEN: Enable Stall Instruction (CPUCON2.6)
_STEN     EQU   0       ; 0 = Stall instruction disabled
                        ; 1 = Stall instruction enabled
;
; <q> EIOIAEN: Early IO Injection Acknowledge guaranteed (CPUCON2.7)
_EIOIAEN  EQU   1       ; 0 = Injection ack. by destructive read not guaranteed
;                       ; 1 = Injection ack. by destructive read guaranteed
; 
; <q> BYPF: Enable Fetch Bypass Control (CPUCON2.8)
_BYPF     EQU   1       ; 0 = Bypass Path from Fetch to Decode disabled
                        ; 1 = Bypass Path from Fetch to Decode enabled
;
; <q> BYPPF: Enable Prefecth Bypass Control (CPUCON2.9)
_BYPPF    EQU   1       ; 0 = Bypass Path from Prefetch to Decode disabled
                        ; 1 = Bypass Path from Prefetch to Decode enabled
;
; <o> FIFOFED: FIFO Fill Configuration (CPUCON2.10 .. CPUCON2.11)
; <0=> FIFO disabled    <1=> 1 instruction
; <2=> 2 instructions   <3=> 3 instructions
_FIFOFED  EQU   3       ; 0 = FIFO disabled
                        ; 1 = FIFO filled with up to 1 instruction per cycle
                        ; 2 = FIFO filled with up to 2 instructions per cycle
                        ; 3 = FIFO filled with up to 3 instructions per cycle
;
;<o> FIFODEPTH: FIFO Depth Configuration (CPUCON2.12 .. CPUCON2.15) <0-8>
_FIFODEPTH EQU  8       ; 0 = No FIFO entries (No FIFO)
                        ; 1 = 1 FIFO entry
                        ; ...
                        ; 8 = 8 FIFO entries
                        ; 9 - 15 = reserved
;</e>

; <e> Internal Memory Block Control
; =================================
;
;  INIT_IMBCTR: Init IMBCTR register
; --- <i>Set INIT_IMBCTR = 1 to initialize the IMBCTRL/H register
$SET (INIT_IMBCTR = 0)  ; default: do not initialize IMBCTR  
;
; <h> Definitions for Internal Memory Block Control Register IMBCTRL
; ==================================================================
;
; <o> WSFLASH: Wait States for the Flash Memory (IMBCTRL.0 .. IMBCTRL.2)<1-7>
; <i> this value also specifies the read time of the PSRAM in the flash emulation address range
_WSFLASH  EQU   4       ; 0 = No waitstates (forbidden!)
                        ; 1-7 = One to seven waitstate
;
; <q> DLCPF: Disable Linear Code Pre-Fetch (IMBCTRL.3)
; <0=> High Speed Mode
; <1=> Low Power Mode
_DLCPF    EQU   1       ; 0 = High Speed Mode
                        ; 1 = Low Power Mode
;
; <o> DCF: Disable Code Fetch from Flash Memory (IMBCTRL.12 .. IMBCTRL.13)
; <i> values 0 and 3 are not allowed
; <1=> no instruction fetch if RPA 1
; <2=> instructions can always be fetched
_DCF      EQU   1       ; 0 = Illegal state
                        ; 1 = no instruction fetch if RPA=1
                        ; 2 = instructions can always be fetched
                        ; 3 = Illegal state
;
; <o> DDF: Disable Data Fetch from Flash Memory (IMBCTRL.14 .. IMBCTRL.15)
; <i> values 0 and 3 are not allowed
; <1=> no data read if RPA=1
; <2=> data can always be read
_DDF      EQU   1       ; 0 = Illegal state
                        ; 1 = no data read if RPA=1
                        ; 2 = data can always be read
                        ; 3 = Illegal state
;
;</h>

; <h> Definitions for Internal Memory Block Control Register IMBCTRH
; ==================================================================
;
; <o> PSPROT: PSRAM Write Protection (IMBCTRH.8 .. IMBCTRH.15)<0-255>
; <i> The start address of the writable range is E00000H + 1000H*PSPROT
_PSPROT   EQU   0       ; 0  = Complete PSRAM is writable
                        ; ...
                        ; 16 or bigger = PSRAM is write protected
;</h>
;</e>
;
;</h>
;
; <h> Oscillator Control
; ======================
;
; <e> Definitions for Wake-up Clock Register WUOSCCON
; ===================================================
;
; INIT_WUOSCCON: Init WUOSCCON register
; --- Set INIT_WUOSCCON = 1 to initialize the WUOSCCON register
$SET (INIT_WUOSCCON = 0)
;
; <o> FREQSEL: System Clock Select (WUOSCCON.0 .. WUOSCCON.1)
; <0=> 500kHz   <1=> 300 kHz
; <2=> 200kHz   <3=> 130 kHz
_FREQSEL  EQU    0      ; 0 = 500 kHz
                        ; 1 = 300 kHz
                        ; 2 = 200 kHz
                        ; 3 = 130 kHz
;
; <o> PWSEL: Power Consumption Selection (WUOSCCON.2 .. WUOSCCON.3)
; <0=> not specified <1=> not specified
; <2=> not specified <3=> not specified
_PWSEL    EQU    0      ; 0 = not specified
                        ; 1 = not specified
                        ; 2 = not specified
                        ; 3 = not specified
;
; <q> DIS: Clock Disable (WUOSCCON.4)
; <i> enables the automatic asyncronous switch to the emergency clock 
; <i> in case of an OSCWDT or VCOLCK emergency event
_DIS      EQU    0      ; 0 = Clock is enabled
                        ; 1 = Clock is disabled
;
; </e>
;
;  <e> Definitions for High Precision Oscillator Register HPOSCCON
; ================================================================
;
; INIT_HPOSCCON: Init HPOSCCON register
; --- Set INIT_HPOSCCON = 1 to initialize the HPOSCCON register
$SET (INIT_HPOSCCON = 1)
;
; <q> OSCWDTRST: Oscillator Watchdog Reset (HPOSCCON.1)
; <i> specifies if the oscillator watchdog will be reset 
_OSCWDTRST EQU   0      ; 0 = The oscillator watchdog of the PLL is not reset and remains active
                        ; 1 = The oscillator watchdog of the PLL is reset and restarted
;
; <o> MODE: Oscillator Mode (HPOSCCON.2 .. HPOSCCON.3)
; <0=>External Crystal Mode. Power-Saving Mode is not entered     <1=>OSC_HP disabled. Power-Saving Mode is not entered
; <2=>External Input Clock Mode. Power-Saving Mode is not entered <3=>OSC_HP disabled. Power-Saving Mode is entered
_MODE     EQU    0      ; 0 = External Crystal Mode. Power-Saving Mode is not entered
                        ; 1 = OSC_HP disabled. Power-Saving Mode is not entered
                        ; 2 = External Input Clock Mode. Power-Saving Mode is not entered
                        ; 3 = OSC_HP disabled. Power-Saving Mode is entered (default)
;
; <q> X1DEN: XTAL1 Data Enable (HPOSCCON.7)
; <i> specifies if X1D reflects the inverted level of XTAL1 
_X1DEN    EQU    0      ; 0 = Bit X1D is not updated
                        ; 1 = Bit X1D reflects the inverted level of XTAL1
;
; <q> SHBY: Shaper Bypass (HPOSCCON.8)
; <i> Switch shaper or/off
_SHBY     EQU    0      ; 0 = The shaper is not bypassed
                        ; 1 = The shaper is bypassed
;
; <q> EMCLKEN: OSCWDT Emergency System Clock Source Select Enable (HPOSCCON.9)
; <i> Clock selection in case of an OSCWDT emergency
_HP_EMCLKEN EQU  0      ; 0 = MCM controlled by SYSCON0.CLKSEL
                        ; 1 = MCM controlled by SYSCON0.EMCLKSEL
;
; <q> EMFINDISEN: Emergency Input Clock Disconnect Enable (HPOSCCON.10)
; <i> defines whether bit PLLSTAT.FINDIS is set in an emergency
_HP_EMFINDISEN EQU 0    ; 0 = No update of PLLSTAT.FINDIS
                        ; 1 = PLLSTAT.FINDIS is set in an OSCWDT emergency case
;
; </e>
;
;  <e> Definitions for Trimmed Current Controlled Clock Control Register PLLOSCCON
; ================================================================================
;
; INIT_PLLOSCCON: Init PLLOSCCON register
; --- Set INIT_PLLOSCCON = 1 to initialize the PLLOSCCON register
$SET (INIT_PLLOSCCON = 0)
;
; <q> OSCPD: Clock Source Power Saving Mode (PLLOSCCON.0)
; <i> Set this bit to 1 to switch-off the trimmed current controlled clock source
_OSCPD    EQU    0      ; 0 = Trimmed current controlled clock source is active
                        ; 1 = Trimmed current controlled clock source is off
;
; </e>
; </h>
;
; <e> PLL Control
; ===============
;
; INIT_PLLCON: Init PLLCON register
; --- Set INIT_PLLCON = 1 to initialize all the PLLCONx register
$SET (INIT_PLLCON = 1)
;
;  <h> Definitions for PLL Clock Register PLLCON0
; ===============================================
;
; <o> VCOBY: VCO Bypass (PLLCON0.0)
; <i> specifies if VCO is bypassed or not
; <0=> Normal operation, VCO is not bypassed
; <1=> Prescaler Mode. VCO is bypassed
_VCOBY    EQU    0      ; 0 = Normal operation, VCO is not bypassed
                        ; 1 = Prescaler Mode. VCO is bypassed
;
; <q> VCOPWD: VCO Power Saving Mode (PLLCON0.1)
; <i> disables VCO
_VCOPWD   EQU    0      ; 0 = VCO is active
                        ; 1 = VCO is inactive in power saving mode
;
; <o> VCOSEL: VCO Range Select (PLLCON0.2 .. PLLCON0.3)
; <0=> 48...112 MHz (Values may vary. See datasheet)
; <1=> 96...160 MHz (Values may vary. See datasheet)
; <2=> 192...340 MHz (not available on all devices. See datasheet)
; <3=> Reserved, do not use
; <i> VCOSEL VCO Range Select
_VCOSEL   EQU    1      ; 0 =  48...112 MHz (depending on device)
                        ; 1 =  96...160 MHz (depending on device)
                        ; 2 = 192...340 MHz (n/a on all devices)
                        ; 3 = reserved
;
; <o> REGENCLR: Power Regulator Enable Clear (PLLCON0.4)
; <0=> No action
; <1=> Switch off the PLL's power regulator
; <i> REGENCLR Power Regulator Enable Clear
_REGENCLR EQU    0      ; 0 = no action
                        ; 1 = switch off the PLL's power regulator
;
; <o> REGENSET: Power Regulator Enable Set (PLLCON0.5)
; <0=> No action
; <1=> Switch on the PLL's power regulator
; <i> REGENSET Power Regulator Enable Set
_REGENSET EQU    0      ; 0 = no action
                        ; 1 = switch on the PLL's power regulator
;
; <o> INSEL: PLL Input Select (PLLCON0.6 .. PLLCON0.7)
; <0=> fosc is selected
; <1=> fclkin1 is selected
; <2=> Reserved, do not use
; <3=> Reserved, do not use
; <i> INSEL PLL Input Select (n/a on all devices)
_INSEL    EQU    0      ; 0 = no action
                        ; 1 = switch on the PLL's power regulator
;
; <o> NDIV: N-Divider Value (PLLCON0.8 .. PLLCON0.13) <8-50>
; <i> The resulting factor N for the N-Divider is (NDIV+1)
; <i> Check the datasheet of your device for allowed values
_NDIV     EQU    19
;
; </h>
;
;  <h> Definitions for PLL Clock Register PLLCON1
; ===============================================
;
; <q> PLLPWD: Power Saving Mode (PLLCON1.0)
; <i> disables PLL in power saving mode
_PLLPWD   EQU    0      ; 0 = Normal Mode
                        ; 1 = Complete PLL block is inactive in power saving mode
;
; <o> OSCSEL: Clock Input Selection (PLLCON1.1)
; <i> selects PLL input clock
; <0=> external oscillator (OSC_HP)
; <1=> internal oscillator (IOSC)
_OSCSEL   EQU    0      ; 0 = PLL input clock is OSC_HP output
                        ; 1 = PLL input clock is IOSC output
;
; <q> AOSCSEL: Asyncronous Clock Input Selection (PLLCON1.3)
; <i> 
_AOSCSEL  EQU    0      ; 0 = Configuration is controlled via bis OSCSEL
                        ; 1 = PLL internal clock IOSC is selected asyncronously
;
; <q> EMCLKEN: VCOLCK Emergency System Clock Source Select Enable (PLLCON1.5)
; <i> Master clock selection in case of emergency
_PLL_EMCLKEN EQU 0      ; 0 = MCM controlled by SZSCON0.CLKSEL
                        ; 1 = MCM controlled by SZSCON0.EMCLKSEL in a VCOLCK emergency case
;
; <q> EMFINDISEN: Emergency Input Clock Disconnect Enable (PLLCON1.6)
; <i> specifies if PLLSTAT.FINDIS is set in a VCOLCK emergency case
_PLL_EMFINDISEN EQU 0   ; 0 = No update of PLLSTAT.FINDIS
                        ; 1 = PLLSTAT.FINDIS is set in a VCOLCK emergency case
;
; <o> PDIV: P-Divider Value (PLLCON1.8 .. PLLCON1.11) <0-15>
; <i> The resulting factor P for the P-Divider is (PDIV+1)
_PDIV     EQU    0
;
; </h>
;
;  <h> Definitions for PLL Clock Register PLLCON2
; ===============================================
;
; <o> K1DIV: K1-Divider Value (PLLCON2.0 .. PLLCON2.9) <0-1023>
; <i> The resulting factor K1 for the K1-Divider is (K1DIV+1)
_K1DIV    EQU    1
;
; </h>
;
;  <h> Definitions for PLL Clock Register PLLCON3
; ===============================================
;
; <o> K2DIV: K2-Divider Value (PLLCON3.0 .. PLLCON3.9) <0-1023>
; <i> The resulting factor K2 for the K2-Divider is (K2DIV+1)
_K2DIV    EQU    1
;
; </h>
; </e>
;
; <h> System Contol
; =================
;
; <e> Definitions for System Configuration Register SYSCON0
; =========================================================
;
; INIT_SYSCON0: Init SYSCON0 register
; --- Set INIT_SYSCON0 = 1 to initialize the SYSCON0 register
$SET (INIT_SYSCON0 = 0)
;
; <o> CLKSEL: System Clock Select (SYSCON0.0 .. SYSCON0.1)
; <0=> WUT clock output <1=> OSC_HP output
; <2=> PLL clock output <3=> DIRIN clock input
_CLKSEL   EQU    2      ; 0 = WUT clock output
                        ; 1 = OSC_HP output
                        ; 2 = PLL clock output
                        ; 3 = Direct Input clock DIRIN
;
; <o> EMCLKSEL: Emergency Clock Select (SYSCON0.3 .. SYSCON0.4)
; <0=> WUT clock output <1=> OSC_HP output
; <2=> PLL clock output <3=> DIRIN clock input
_EMCLKSEL EQU    0      ; 0 = WUT clock output
                        ; 1 = OSC_HP output
                        ; 2 = PLL clock output
                        ; 3 = Direct Input clock DIRIN
;
; <q> EMCLKSELEN: Emergency Clock Select Enable (SYSCON0.6)
; <i> enables the automatic asyncronous switch to the emergency clock 
; <i> in case of an OSCWDT or VCOLCK emergency event
_EMCLKSELEN EQU  0      ; 0 = Emergency clock switch is disabled
                        ; 1 = Emergency clock switch is enabled
;
; </e>
;</h>
;
;
; <e> Definitions for External Service Request (ESR) Pins
; =======================================================
;
; INIT_ESRCFG: Init ESRCFG0/1/2 register
; --- Set INIT_ESRCFG = 1 to initilize the ESRCFG0/1/2 register
$SET (INIT_ESRCFG = 0)
;
; <o> ESR 0: Pin Control(ESRCFG.PC)
; <0=> No pull device activated. Input is not inverted
; <1=> Pull-down device activated. Input is not inverted
; <2=> Pull-up device activated. Input is not inverted
; <3=> No pull device activated. Input is not inverted
; <4=> No pull device activated. Input is inverted
; <5=> Pull-down device activated. Input is inverted
; <6=> Pull-up device activated. Input is inverted
; <7=> No pull device activated. Input is inverted
; <8=> Output of ESRCFGx.OUT. Push-pull
; <9=> Output of ESRCFGx.OUT. Push-pull
; <10=> Output drives a 0 for an Internal Application Reset, a 1 otherwise. Push-pull
; <11=> Output drives a 0 for an Application Reset, a 1 otherwise. Push-pull
; <12=> Output of ESRCFGx.OUT. Open-drain
; <13=> Output of ESRCFGx.OUT. Open-drain
; <14=> Output drives a 0 for an Internal Application Reset. Open-drain
; <15=> Output drives a 0 for an Application Reset. Open-drain
_ESR_PC0    EQU  14     ;  0 = No pull device activated. Input is not inverted
                        ;  1 = Pull-down device activated. Input is not inverted
                        ;  2 = Pull-up device activated. Input is not inverted
                        ;  3 = No pull device activated. Input is not inverted
                        ;  4 = No pull device activated. Input is inverted
                        ;  5 = Pull-down device activated. Input is inverted
                        ;  6 = Pull-up device activated. Input is inverted
                        ;  7 = No pull device activated. Input is inverted
                        ;  8 = Output of ESRCFGx.OUT. Push-pull
                        ;  9 = Output of ESRCFGx.OUT. Push-pull
                        ; 10 = Output drives a 0 for an Internal Application Reset, a 1 otherwise. Push-pull
                        ; 11 = Output drives a 0 for an Application Reset, a 1 otherwise. Push-pull
                        ; 12 = Output of ESRCFGx.OUT. Open-drain
                        ; 13 = Output of ESRCFGx.OUT. Open-drain
                        ; 14 = Output drives a 0 for an Internal Application Reset. Open-drain
                        ; 15 = Output drives a 0 for an Application Reset. Open-drain


; <o> ESR 1: Pin Control(ESRCFG.PC) if avalible
; <0=> No pull device activated. Input is not inverted
; <1=> Pull-down device activated. Input is not inverted
; <2=> Pull-up device activated. Input is not inverted
; <3=> No pull device activated. Input is not inverted
; <4=> No pull device activated. Input is inverted
; <5=> Pull-down device activated. Input is inverted
; <6=> Pull-up device activated. Input is inverted
; <7=> No pull device activated. Input is inverted
; <8=> Output of ESRCFGx.OUT. Push-pull
; <9=> Output of ESRCFGx.OUT. Push-pull
; <10=> Output drives a 0 for an Internal Application Reset, a 1 otherwise. Push-pull
; <11=> Output drives a 0 for an Application Reset, a 1 otherwise. Push-pull
; <12=> Output of ESRCFGx.OUT. Open-drain
; <13=> Output of ESRCFGx.OUT. Open-drain
; <14=> Output drives a 0 for an Internal Application Reset. Open-drain
; <15=> Output drives a 0 for an Application Reset. Open-drain
_ESR_PC1    EQU  2      ;  0 =  No pull device activated. Input is not inverted
                        ;  1 = Pull-down device activated. Input is not inverted
                        ;  2 = Pull-up device activated. Input is not inverted
                        ;  3 = No pull device activated. Input is not inverted
                        ;  4 = No pull device activated. Input is inverted
                        ;  5 = Pull-down device activated. Input is inverted
                        ;  6 = Pull-up device activated. Input is inverted
                        ;  7 = No pull device activated. Input is inverted
                        ;  8 = Output of ESRCFGx.OUT. Push-pull
                        ;  9 = Output of ESRCFGx.OUT. Push-pull
                        ; 10 = Output drives a 0 for an Internal Application Reset, a 1 otherwise. Push-pull
                        ; 11 = Output drives a 0 for an Application Reset, a 1 otherwise. Push-pull
                        ; 12 = Output of ESRCFGx.OUT. Open-drain
                        ; 13 = Output of ESRCFGx.OUT. Open-drain
                        ; 14 = Output drives a 0 for an Internal Application Reset. Open-drain
                        ; 15 = Output drives a 0 for an Application Reset. Open-drain


; <o> ESR 2: Pin Control(ESRCFG.PC) if avalible
; <0=> No pull device activated. Input is not inverted
; <1=> Pull-down device activated. Input is not inverted
; <2=> Pull-up device activated. Input is not inverted
; <3=> No pull device activated. Input is not inverted
; <4=> No pull device activated. Input is inverted
; <5=> Pull-down device activated. Input is inverted
; <6=> Pull-up device activated. Input is inverted
; <7=> No pull device activated. Input is inverted
; <8=> Output of ESRCFGx.OUT. Push-pull
; <9=> Output of ESRCFGx.OUT. Push-pull
; <10=> Output drives a 0 for an Internal Application Reset, a 1 otherwise. Push-pull
; <11=> Output drives a 0 for an Application Reset, a 1 otherwise. Push-pull
; <12=> Output of ESRCFGx.OUT. Open-drain
; <13=> Output of ESRCFGx.OUT. Open-drain
; <14=> Output drives a 0 for an Internal Application Reset. Open-drain
; <15=> Output drives a 0 for an Application Reset. Open-drain
_ESR_PC2    EQU  2      ;  0 =  No pull device activated. Input is not inverted
                        ;  1 = Pull-down device activated. Input is not inverted
                        ;  2 = Pull-up device activated. Input is not inverted
                        ;  3 = No pull device activated. Input is not inverted
                        ;  4 = No pull device activated. Input is inverted
                        ;  5 = Pull-down device activated. Input is inverted
                        ;  6 = Pull-up device activated. Input is inverted
                        ;  7 = No pull device activated. Input is inverted
                        ;  8 = Output of ESRCFGx.OUT. Push-pull
                        ;  9 = Output of ESRCFGx.OUT. Push-pull
                        ; 10 = Output drives a 0 for an Internal Application Reset, a 1 otherwise. Push-pull
                        ; 11 = Output drives a 0 for an Application Reset, a 1 otherwise. Push-pull
                        ; 12 = Output of ESRCFGx.OUT. Open-drain
                        ; 13 = Output of ESRCFGx.OUT. Open-drain
                        ; 14 = Output drives a 0 for an Internal Application Reset. Open-drain
                        ; 15 = Output drives a 0 for an Application Reset. Open-drain
; </e>
;
;
;
; <e> Watchdog Timer
; ==================
;
; --- Set WATCHDOG = 0 to enable the Hardware watchdog and initialize the WDTCON register
$SET (WATCHDOG = 0)     ; 0 = Disabled Hardware watchdog
;
; <o> IR: Input Frequency Request Bit (WDTCS.8)
; <0=> Peripheral Frequency divided by 16384
; <1=> Peripheral Frequency divided by 256 
_IR       EQU    0      ; 0 = frequency f_peripheral / 16384 (CPU default)  
                        ; 1 = frequency f_peripheral / 256
;
; <o> WDTREL: Watchdog Timer Reload Value (WDTREL0 .. WDTREL15) <0-65535>
; <i> Reload value of WDT (counts up, overflow gives Watchdog reset)
_WDTREL   EQU    0      
;
; </e>
;
; <h> External Bus Configuration
;
; <e> Configure External Bus (EBC) Behaviour
; ==========================================
;
; --- Set CONFIG_EBC = 0 to initialize the EBCMOD0/EBCMOD1 registers
$SET (CONFIG_EBC = 0)   ; 0 = EBCMOD0/EBCMOD1 are set during reset according the 
                        ;     of configuration bus (typical Port0) values.
                        ; 1 = the following external bus configuration values
                        ;     are written to EBCMOD and BUSACT0
;
; <h> Definitions for EBC Mode 0 register EBCMOD0
; ===============================================
;
; <o> SAPEN: Segment Address Pins Enabled (EBCMOD0.0 .. EBCMOD0.3) <0-8>
; <i> Number of active Address Lines (A16-A23)
_SAPEN      EQU    0    ; 0 = No segment address pins enabled
                        ; 1 = One (A16) segment address pin enabled
                        ; : = :        
                        ; 8 = Eight (A16 .. A23) address pins enabled
                        ; 9 - 15 = reserved
;
; <o> CSPEN: CSx Pins Enabled (EBCMOD0.4 .. EBCMOD0.7) <0-8>
; <i> Number of active ChipSelect pins
_CSPEN      EQU    8    ; 0 = No CS pins enabled
                        ; 1 = One CS (CS0) pin enabled
                        ; : = :
                        ; 8 = Eight CS (CS0 .. CS7) pins enabled
                        ; 9 - 15 = reserved
; Note: the number of available CS pins depends on the chip used
;
; <q> ARBEN: Enable Bus Arbitration Pins (EBCMOD0.8)
_ARBEN      EQU    0    ; 0 = HOLD, HLDA and BREQ pins are tristate or act as GPIO
                        ; 1 = HOLD, HLDA and BREQ pins act normally
;
; <o> SLAVE: SLAVE mode enable (EBCMOD0.9)
; <0=> Master Mode  <1=> Slave Mode
_SLAVE      EQU    0    ; 0 = Bus arbiter acts in master mode
                        ; 1 = Bus arbiter acts in slave mode
;
; <q> EBCDIS: Disable EBC pins (EBCMOD0.10)
_EBCDIS     EQU    0    ; 0 = EBC is using the pins for external bus
                        ; 1 = EBC off (pins to be used as GPIO if implemented)
;
; <o> WRCFG: Configuration for pins WR/WRL and BHE/WRH (EBCMOD0.11)
; <0=> WR and BHE  <1=> WRL and WRH
_WRCFG      EQU    0    ; 0 = Pins act as WR and BHE
                        ; 1 = Pins act as WRL and WRH
;
; <q> BYTDIS: Disable BHE pin (EBCMOD0.12)
_BYTDIS     EQU    0    ; 0 = BHE enabled
                        ; 1 = BHE disabled (GPIO function if implemented)
;
; <q> ALEDIS: Disable ALE pin (EBCMOD0.13)
_ALEDIS     EQU    0    ; 0 = ALE pin enabled
                        ; 1 = ALE pin disabled (GPIO function if implemented)
;
; <q> RDYDIS: Disable READY pin (EBCMOD0.14)
_RDYDIS     EQU    0    ; 0 = READY enabled
                        ; 1 = READY disabled (GPIO function if implemented)
;
; <o> RDYPOL: READY pin polarity (EBCMOD0.15)
; <0=> Active Low  <1=> Active High
_RDYPOL     EQU    0    ; 0 = READY pin is active low
                        ; 1 = READY pin is active high
;
;</h>
;
; <h>Definitions for EBC Mode 1 register EBCMOD1
; ==============================================
;
; <o> APDIS: Address Port Pins Disable (EBCMOD1.0 .. EBCMOD1.3) <0-15>
_APDIS     EQU    0     ; 0  = Address bus pins 15-1 of PORT1 enabled
                        ; 1  = Pin A15 disabled, A14-1 enabled
                        ; 2  = Pin A15-A14 disabled, A13-1 enabled
                        ; ...
                        ; 15 = Pins A15-A1 disabled
;
; <q> A0PDIS: Address Bit 0 Pin Disable (EBCMOD1.4)
_A0PDIS    EQU    0     ; 0 = Address bus pin 0 of PORT1 enabled
                        ; 1 = Address bus pin 0 of PORT1 disabled
;
; <q> ALPDIS: Address Low Pins Disable (EBCMOD1.5)
_ALPDIS    EQU    0     ; 0 = Address bus pin 7-0 generally enabled
                        ; 1 = Address bus pin 7-0 of PORT1 disabled
;
; <q> DHPDIS: Data High Port Pins Disable (EBCMOD1.6)
_DHPDIS    EQU    0     ; 0 = Data bus pins 15-8 of PORT0 enabled
                        ; 1 = Data bus pins 15-8 disabled (used as GPIO)
;
; <q> WRPDIS: WR/WRL Pin Disable (EBCMOD1.7)
_WRPDIS    EQU    0     ; 0 = WR/WRL pin of Port P20 enabled
                        ; 1 = WR/WRL pin of Port P20 disabled
;
;</h></e>
;
; <e> Configure External Bus Behaviour for CS0 area
; =================================================
;
; --- Set CONFIG_CS0 = 1 to initialize the FCONCS0/TCONCS0 registers
$SET (CONFIG_CS0 = 0)
;
; <h>Definitions for Function Configuration Register FCONCS0
; ==========================================================
;
; <q> ENCS0: Enable Chip Select (FCONCS0.0)
_ENCS0     EQU    1     ; 0 = Chip Select 0 disabled
                        ; 1 = Chip Select 0 enabled
;
; <q> RDYEN0: Ready Enable (FCONCS0.1)
_RDYEN0    EQU    0     ; 0 = Access time controlled by TCONCS0.PHE0
                        ; 1 = Access time cont. by TCONCS0.PHE0 and READY signal
;
; <o> RDYMOD0: Ready Mode (FCONCS0.2) 
; <0=> Asynchronous  <1=> Synchronous
_RDYMOD0   EQU    0     ; 0 = Asynchronous READY
                        ; 1 = Synchronous READY
;
; <o> BTYP0: Bus Type Selection (FCONCS0.4 .. FCONCS0.5)
; <0=> 8-bit Demultiplexed Bus  <1=> 8-bit Multiplexed Bus
; <2=> 16-bit Demultiplexed Bus <3=> 16-bit Multiplexed Bus
_BTYP0     EQU    2     ; 0 = 8 bit Demultiplexed bus
                        ; 1 = 8 bit Multiplexed bus
                        ; 2 = 16 bit Demultiplexed bus
                        ; 3 = 16 bit Multiplexed bus
; </h>
;
; <h> TCONCS0: Definitions for the Timing Configuration register 
; ==============================================================
;
; <o> PHA0: Phase A clock cycles (TCONCS0.0 .. TCONCS0.1) <0-3>
_PHA0       EQU    0    ; 0 = 0 clock cycles
                        ; : = : 
                        ; 3 = 3 clock cycles
;
; <o> PHB0: Phase B clock cycles (TCONCS0.2) <1-2> <#-1>
_PHB0       EQU    0    ; 0 = 1 clock cycle
                        ; 1 = 2 clock cycles
;
; <o> PHC0: Phase C clock cycles (TCONCS0.3 .. TCONCS0.4) <0-3>
_PHC0       EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o> PHD0: Phase D clock cycle (TCONCS0.5) <0-1>
_PHD0       EQU    0    ; 0 = 0 clock cycles
                        ; 1 = 1 clock cycle
;
; <o> PHE0: Phase E clock cycles (TCONCS0.6 .. TCONCS0.10) <1-32> <#-1>
_PHE0       EQU    8    ; 0 = 1 clock cycle
                        ; : = :
                        ; 31 = 32 clock cycles
;
; <o> RDPHF0: Phase F read clock cycles (TCONCS0.11 .. TCONCS0.12) <0-3>
_RDPHF0     EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o> WRPHF0: Phase F write clock cycles (TCONCS0.13 .. TCONCS0.14) <0-3>
_WRPHF0     EQU    3    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;</h> </e>
;
; <e> Configure External Bus Behaviour for CS1 Area
; =================================================
;
; --- Set CONFIG_CS1 = 1 to initialize the ADDRSEL1/FCONCS1/TCONCS1 registers
$SET (CONFIG_CS1 = 0)
;
; <h>Definitions for Address Select register ADDRSEL1
; ===================================================
; <o> CS1 Start Address   <0x0-0xFFFFFF:0x1000>
_ADDR1      EQU 0x100000     ; Set CS1# Start Address (default 100000H)

; <o> CS1 Size in KB      
; <4=>    4KB      <8=>    8KB      <16=>   16KB     <32=>   32KB   
; <64=>   64KB     <128=>  128KB    <256=>  256KB    <512=>  512KB
; <1024=> 1024KB   <2048=> 2048KB   <4096=> 4096KB   <8192=> 8192KB
_SIZE1      EQU 1024*KB         ; Set CS1# Size (default 1024*KB = 1*MB)
                             ; possible values for _SIZE1 are:
                             ;    4*KB            (gives RGSZ1 = 0)
                             ;    8*KB            (gives RGSZ1 = 1)
                             ;   16*KB            (gives RGSZ1 = 2)
                             ;   32*KB            (gives RGSZ1 = 3)
                             ;   64*KB            (gives RGSZ1 = 4)
                             ;  128*KB            (gives RGSZ1 = 5)
                             ;  256*KB            (gives RGSZ1 = 6)
                             ;  512*KB            (gives RGSZ1 = 7)
                             ; 1024*KB  or  1*MB  (gives RGSZ1 = 8)
                             ; 2048*KB  or  2*MB  (gives RGSZ1 = 9)
                             ; 4096*KB  or  4*MB  (gives RGSZ1 = 10)
                             ; 8192*KB  or  8*MB  (gives RGSZ1 = 11)
                             ;                    (RGSZ1 = 12 .. 15 reserved)
;</h>
;
; <h>Definitions for Function Configuration Register FCONCS1
; ==========================================================
;
; <q> ENCS1: Enable Chip Select (FCONCS1.0)
_ENCS1     EQU    1     ; 0 = Chip Select 0 disabled
                        ; 1 = Chip Select 0 enabled
;
; <q> RDYEN1: Ready Enable (FCONCS1.1)
_RDYEN1    EQU    0     ; 0 = Access time controlled by TCONCS1.PHE1
                        ; 1 = Access time cont. by TCONCS1.PHE1 and READY signal
;
; <o> RDYMOD1: Ready Mode (FCONCS1.2)
; <0=> Asynchronous  <1=> Synchronous
_RDYMOD1   EQU    0     ; 0 = Asynchronous READY
                        ; 1 = Synchronous READY
;
; <o> BTYP1: Bus Type Selection (FCONCS1.4 .. FCONCS1.5)
; <0=> 8-bit Demultiplexed Bus  <1=> 8-bit Multiplexed Bus
; <2=> 16-bit Demultiplexed Bus <3=> 16-bit Multiplexed Bus
_BTYP1     EQU    2     ; 0 = 8 bit Demultiplexed bus
                        ; 1 = 8 bit Multiplexed bus
                        ; 2 = 16 bit Demultiplexed bus
                        ; 3 = 16 bit Multiplexed bus
;</h>
;
; <h>TCONCS1: Definitions for the Timing Configuration register 
; =============================================================
;
; <o>PHA1: Phase A clock cycles (TCONCS1.0 .. TCONCS1.1) <0-3>
_PHA1       EQU    0    ; 0 = 0 clock cycles
                        ; : = : 
                        ; 3 = 3 clock cycles
;
; <o>PHB1: Phase B clock cycles (TCONCS1.2) <1-2> <#-1>
_PHB1       EQU    0    ; 0 = 1 clock cycle
                        ; 1 = 2 clock cycles
;
; <o>PHC1: Phase C clock cycles (TCONCS1.3 .. TCONCS1.4) <0-3>
_PHC1       EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o>PHD1: Phase D clock cycles (TCONCS1.5) <0-1>
_PHD1       EQU    0    ; 0 = 0 clock cycles
                        ; 1 = 1 clock cycle
;
; <o> PHE1: Phase E clock cycles (TCONCS1.6 .. TCONCS1.10) <1-32> <#-1>
_PHE1       EQU    8    ; 0 = 1 clock cycle
                        ; : = :
                        ; 31 = 32 clock cycles
;
; <o>RDPHF1: Phase F read clock cycles (TCONCS1.11 .. TCONCS1.12) <0-3>
_RDPHF1     EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o>WRPHF1: Phase F write clock cycles (TCONCS1.13 .. TCONCS1.14) <0-3>
_WRPHF1     EQU    3    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;</h> </e>
;
;<e>Configure External Bus Behaviour for CS2 Area
;   =============================================
;
; --- Set CONFIG_CS2 = 1 to initialize the ADDRSEL2/FCONCS2/TCONCS2 registers
$SET (CONFIG_CS2 = 0)
;
; <h>Definitions for Address Select register ADDRSEL2
; ===================================================
; <o> CS2 Start Address   <0x0-0xFFFFFF:0x1000>
_ADDR2      EQU 0x200000     ; Set CS2# Start Address (default 100000H)

; <o> CS2 Size in KB      
; <4=>    4KB      <8=>    8KB      <16=>   16KB     <32=>   32KB
; <64=>   64KB     <128=>  128KB    <256=>  256KB    <512=>  512KB
; <1024=> 1024KB   <2048=> 2048KB   <4096=> 4096KB   <8192=> 8192KB
_SIZE2      EQU 1024*KB         ; Set CS2# Size (default 1024*KB = 1*MB)
                             ; possible values for _SIZE2 are:
                             ;    4*KB            (gives RGSZ2 = 0)
                             ;    8*KB            (gives RGSZ2 = 1)
                             ;   16*KB            (gives RGSZ2 = 2)
                             ;   32*KB            (gives RGSZ2 = 3)
                             ;   64*KB            (gives RGSZ2 = 4)
                             ;  128*KB            (gives RGSZ2 = 5)
                             ;  256*KB            (gives RGSZ2 = 6)
                             ;  512*KB            (gives RGSZ2 = 7)
                             ; 1024*KB  or  1*MB  (gives RGSZ2 = 8)
                             ; 2048*KB  or  2*MB  (gives RGSZ2 = 9)
                             ; 4096*KB  or  4*MB  (gives RGSZ2 = 10)
                             ; 8192*KB  or  8*MB  (gives RGSZ2 = 11)
                             ;                    (RGSZ2 = 12 .. 15 reserved)
;</h>
;
; <h>Definitions for Function Configuration Register FCONCS2
; ==========================================================
;
; <q> ENCS2: Enable Chip Select (FCONCS2.0)
_ENCS2     EQU    1     ; 0 = Chip Select 0 disabled
                        ; 1 = Chip Select 0 enabled
;
; <q> RDYEN2: Ready Enable (FCONCS2.1)
_RDYEN2    EQU    0     ; 0 = Access time controlled by TCONCS2.PHE1
                        ; 1 = Access time cont. by TCONCS2.PHE1 and READY signal
;
; <o> RDYMOD2: Ready Mode (FCONCS2.2)
; <0=> Asynchronous  <1=> Synchronous
_RDYMOD2   EQU    0     ; 0 = Asynchronous READY
                        ; 1 = Synchronous READY
;
; <o> BTYP2: Bus Type Selection (FCONCS2.4 .. FCONCS2.5)
; <0=> 8-bit Demultiplexed Bus  <1=> 8-bit Multiplexed Bus
; <2=> 16-bit Demultiplexed Bus <3=> 16-bit Multiplexed Bus
_BTYP2     EQU    2     ; 0 = 8 bit Demultiplexed bus
                        ; 1 = 8 bit Multiplexed bus
                        ; 2 = 16 bit Demultiplexed bus
                        ; 3 = 16 bit Multiplexed bus
;</h>
;
; <h>TCONCS2: Definitions for the Timing Configuration register 
; =============================================================
;
; <o>PHA2: Phase A clock cycle (TCONCS2.0 .. TCONCS2.1) <0-3>
_PHA2       EQU    0    ; 0 = 0 clock cycles
                        ; : = : 
                        ; 3 = 3 clock cycles
;
; <o>PHB2: Phase B clock cycle (TCONCS2.2) <1-2> <#-1>
_PHB2       EQU    0    ; 0 = 1 clock cycle
                        ; 1 = 2 clock cycles
;
; <o>PHC2: Phase C clock cycle (TCONCS2.3 .. TCONCS2.4) <0-3>
_PHC2       EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o>PHD2: Phase D clock cycle (TCONCS2.5) <0-1>
_PHD2       EQU    0    ; 0 = 0 clock cycles
                        ; 1 = 1 clock cycle
;
; <o> PHE2: Phase E clock cycle (TCONCS2.6 .. TCONCS2.10) <1-32> <#-1>
_PHE2       EQU    8    ; 0 = 1 clock cycle
                        ; : = :
                        ; 31 = 32 clock cycles
;
; <o>RDPHF2: Phase F read clock cycle (TCONCS2.11 .. TCONCS2.12) <0-3>
_RDPHF2     EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o>WRPHF2: Phase F write clock cycle (TCONCS2.13 .. TCONCS2.14) <0-3>
_WRPHF2     EQU    3    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;</h> </e>
;
;<e>Configure External Bus Behaviour for CS3 Area
;   =============================================
;
; --- Set CONFIG_CS3 = 1 to initialize the ADDRSEL3/FCONCS3/TCONCS3 registers
$SET (CONFIG_CS3 = 0)
;
; <h>Definitions for Address Select register ADDRSEL3
; ===================================================
; <o> CS3 Start Address   <0x0-0xFFFFFF:0x1000>
_ADDR3      EQU 0x300000     ; Set CS3# Start Address (default 100000H)

; <o> CS2 Size in KB      
; <4=>    4KB      <8=>    8KB      <16=>   16KB     <32=>   32KB
; <64=>   64KB     <128=>  128KB    <256=>  256KB    <512=>  512KB
; <1024=> 1024KB   <2048=> 2048KB   <4096=> 4096KB   <8192=> 8192KB
_SIZE3      EQU 1024*KB         ; Set CS3# Size (default 1024*KB = 1*MB)
                             ; possible values for _SIZE3 are:
                             ;    4*KB            (gives RGSZ3 = 0)
                             ;    8*KB            (gives RGSZ3 = 1)
                             ;   16*KB            (gives RGSZ3 = 2)
                             ;   32*KB            (gives RGSZ3 = 3)
                             ;   64*KB            (gives RGSZ3 = 4)
                             ;  128*KB            (gives RGSZ3 = 5)
                             ;  256*KB            (gives RGSZ3 = 6)
                             ;  512*KB            (gives RGSZ3 = 7)
                             ; 1024*KB  or  1*MB  (gives RGSZ3 = 8)
                             ; 2048*KB  or  2*MB  (gives RGSZ3 = 9)
                             ; 4096*KB  or  4*MB  (gives RGSZ3 = 10)
                             ; 8192*KB  or  8*MB  (gives RGSZ3 = 11)
                             ;                    (RGSZ3 = 12 .. 15 reserved)
;</h>
;
; <h>Definitions for Function Configuration Register FCONCS3
; ==========================================================
;
; <q> ENCS3: Enable Chip Select (FCONCS3.0)
_ENCS3     EQU    1     ; 0 = Chip Select 0 disabled
                        ; 1 = Chip Select 0 enabled
;
; <q> RDYEN3: Ready Enable (FCONCS3.1)
_RDYEN3    EQU    0     ; 0 = Access time controlled by TCONCS3.PHE1
                        ; 1 = Access time cont. by TCONCS3.PHE1 and READY signal
;
; <o> RDYMOD3: Ready Mode (FCONCS3.2)
; <0=> Asynchronous  <1=> Synchronous
_RDYMOD3   EQU    0     ; 0 = Asynchronous READY
                        ; 1 = Synchronous READY
;
; <o> BTYP3  Bus Type Selection (FCONCS3.4 .. FCONCS3.5)
; <0=> 8-bit Demultiplexed Bus  <1=> 8-bit Multiplexed Bus
; <2=> 16-bit Demultiplexed Bus <3=> 16-bit Multiplexed Bus
_BTYP3     EQU    2     ; 0 = 8 bit Demultiplexed bus
                        ; 1 = 8 bit Multiplexed bus
                        ; 2 = 16 bit Demultiplexed bus
                        ; 3 = 16 bit Multiplexed bus
;</h>
;
; <h>TCONCS3: Definitions for the Timing Configuration register 
; =============================================================
;
; <o>PHA3: Phase A clock cycle (TCONCS3.0 .. TCONCS3.1) <0-3>
_PHA3       EQU    0    ; 0 = 0 clock cycles
                        ; : = : 
                        ; 3 = 3 clock cycles
;
; <o>PHB3: Phase B clock cycle (TCONCS2.2) <1-2> <#-1>
_PHB3       EQU    0    ; 0 = 1 clock cycle
                        ; 1 = 2 clock cycles
;
; <o>PHC3: Phase C clock cycle (TCONCS3.3 .. TCONCS3.4) <0-3>
_PHC3       EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o>PHD3: Phase D clock cycle (TCONCS3.5) <0-1>
_PHD3       EQU    0    ; 0 = 0 clock cycles
                        ; 1 = 1 clock cycle
;
; <o> PHE3: Phase E clock cycle (TCONCS3.6 .. TCONCS3.10) <1-32> <#-1>
_PHE3       EQU    8    ; 0 = 1 clock cycle
                        ; : = :
                        ; 31 = 32 clock cycles
;
; <o>RDPHF3: Phase F read clock cycle (TCONCS3.11 .. TCONCS3.12) <0-3>
_RDPHF3     EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o>WRPHF3: Phase F write clock cycle (TCONCS3.13 .. TCONCS3.14) <0-3>
_WRPHF3     EQU    3    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;</h> </e>
;
;<e>Configure External Bus Behaviour for CS4 Area
;   =============================================
;
; --- Set CONFIG_CS4 = 1 to initialize the ADDRSEL4/FCONCS4/TCONCS4 registers
$SET (CONFIG_CS4 = 0)
;
; <h>Definitions for Address Select register ADDRSEL4
; ===================================================
; <o> CS4 Start Address   <0x0-0xFFFFFF:0x1000>
_ADDR4      EQU 0x400000     ; Set CS4# Start Address (default 100000H)

; <o> CS4 Size in KB      
; <4=>    4KB      <8=>    8KB      <16=>   16KB     <32=>   32KB
; <64=>   64KB     <128=>  128KB    <256=>  256KB    <512=>  512KB
; <1024=> 1024KB   <2048=> 2048KB   <4096=> 4096KB   <8192=> 8192KB
_SIZE4      EQU 1024*KB         ; Set CS4# Size (default 1024*KB = 1*MB)
                             ; possible values for _SIZE4 are:
                             ;    4*KB            (gives RGSZ4 = 0)
                             ;    8*KB            (gives RGSZ4 = 1)
                             ;   16*KB            (gives RGSZ4 = 2)
                             ;   32*KB            (gives RGSZ4 = 3)
                             ;   64*KB            (gives RGSZ4 = 4)
                             ;  128*KB            (gives RGSZ4 = 5)
                             ;  256*KB            (gives RGSZ4 = 6)
                             ;  512*KB            (gives RGSZ4 = 7)
                             ; 1024*KB  or  1*MB  (gives RGSZ4 = 8)
                             ; 2048*KB  or  2*MB  (gives RGSZ4 = 9)
                             ; 4096*KB  or  4*MB  (gives RGSZ4 = 10)
                             ; 8192*KB  or  8*MB  (gives RGSZ4 = 11)
                             ;                    (RGSZ4 = 12 .. 15 reserved)
;</h>
;
; <h>Definitions for Function Configuration Register FCONCS4
; ==========================================================
;
; <q> ENCS4: Enable Chip Select (FCONCS4.0)
_ENCS4     EQU    1     ; 0 = Chip Select 0 disabled
                        ; 1 = Chip Select 0 enabled
;
; <q> RDYEN4: Ready Enable (FCONCS4.1)
_RDYEN4    EQU    0     ; 0 = Access time controlled by TCONCS4.PHE1
                        ; 1 = Access time cont. by TCONCS4.PHE1 and READY signal
;
; <o> RDYMOD4: Ready Mode (FCONCS4.2)
; <0=> Asynchronous  <1=> Synchronous
_RDYMOD4   EQU    0     ; 0 = Asynchronous READY
                        ; 1 = Synchronous READY
;
; <o> BTYP4: Bus Type Selection (FCONCS4.4 .. FCONCS4.5)
; <0=> 8-bit Demultiplexed Bus  <1=> 8-bit Multiplexed Bus
; <2=> 16-bit Demultiplexed Bus <3=> 16-bit Multiplexed Bus
_BTYP4     EQU    2     ; 0 = 8 bit Demultiplexed bus
                        ; 1 = 8 bit Multiplexed bus
                        ; 2 = 16 bit Demultiplexed bus
                        ; 3 = 16 bit Multiplexed bus
;</h>
;
; <h>TCONCS4: Definitions for the Timing Configuration register 
; =============================================================
;
; <o>PHA4: Phase A clock cycle (TCONCS4.0 .. TCONCS4.1) <0-3>
_PHA4       EQU    0    ; 0 = 0 clock cycles
                        ; : = : 
                        ; 3 = 3 clock cycles
;
; <o>PHB4: Phase B clock cycle (TCONCS4.2) <1-2> <#-1>
_PHB4       EQU    0    ; 0 = 1 clock cycle
                        ; 1 = 2 clock cycles
;
; <o>PHC4: Phase C clock cycle (TCONCS4.3 .. TCONCS4.4) <0-3>
_PHC4       EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o>PHD4: Phase D clock cycle (TCONCS4.5) <0-1>
_PHD4       EQU    0    ; 0 = 0 clock cycles
                        ; 1 = 1 clock cycle
;
; <o> PHE4: Phase E clock cycle (TCONCS4.6 .. TCONCS4.10) <1-32> <#-1>
_PHE4       EQU    8    ; 0 = 1 clock cycle
                        ; : = :
                        ; 31 = 32 clock cycles
;
; <o>RDPHF4: Phase F read clock cycle (TCONCS4.11 .. TCONCS4.12) <0-3>
_RDPHF4     EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o>WRPHF4: Phase F write clock cycle (TCONCS4.13 .. TCONCS4.14) <0-3>
_WRPHF4     EQU    3    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;</h> </e>
;
;<e>Configure External Bus Behaviour for CS7 Area
;   =============================================
;
; --- Set CONFIG_CS7 = 1 to initialize the ADDRSEL7/FCONCS7/TCONCS7 registers
$SET (CONFIG_CS7 = 0)
;
; <h>Definitions for Address Select register ADDRSEL7
; ===================================================
; <o> CS7 Start Address   <0x0-0xFFFFFF:0x1000>
_ADDR7      EQU 0x700000     ; Set CS7# Start Address (default 100000H)

; <o> CS7 Size in KB      
; <4=>    4KB      <8=>    8KB      <16=>   16KB     <32=>   32KB
; <64=>   64KB     <128=>  128KB    <256=>  256KB    <512=>  512KB
; <1024=> 1024KB   <2048=> 2048KB   <4096=> 4096KB   <8192=> 8192KB
_SIZE7      EQU 1024*KB         ; Set CS7# Size (default 1024*KB = 1*MB)
                             ; possible values for _SIZE7 are:
                             ;    4*KB            (gives RGSZ7 = 0)
                             ;    8*KB            (gives RGSZ7 = 1)
                             ;   16*KB            (gives RGSZ7 = 2)
                             ;   32*KB            (gives RGSZ7 = 3)
                             ;   64*KB            (gives RGSZ7 = 4)
                             ;  128*KB            (gives RGSZ7 = 5)
                             ;  256*KB            (gives RGSZ7 = 6)
                             ;  512*KB            (gives RGSZ7 = 7)
                             ; 1024*KB  or  1*MB  (gives RGSZ7 = 8)
                             ; 2048*KB  or  2*MB  (gives RGSZ7 = 9)
                             ; 4096*KB  or  4*MB  (gives RGSZ7 = 10)
                             ; 8192*KB  or  8*MB  (gives RGSZ7 = 11)
                             ;                    (RGSZ7 = 12 .. 15 reserved)
;</h>
;
; <h>Definitions for Function Configuration Register FCONCS7
; ==========================================================
;
; <q> ENCS7: Enable Chip Select (FCONCS7.0)
_ENCS7     EQU    1     ; 0 = Chip Select 0 disabled
                        ; 1 = Chip Select 0 enabled
;
; <q> RDYEN7: Ready Enable (FCONCS7.1)
_RDYEN7    EQU    0     ; 0 = Access time controlled by TCONCS7.PHE1
                        ; 1 = Access time cont. by TCONCS7.PHE1 and READY signal
;
; <o> RDYMOD7: Ready Mode (FCONCS7.2)
; <0=> Asynchronous  <1=> Synchronous
_RDYMOD7   EQU    0     ; 0 = Asynchronous READY
                        ; 1 = Synchronous READY
;
; <o> BTYP7: Bus Type Selection (FCONCS7.4 .. FCONCS7.5)
; <0=> 8-bit Demultiplexed Bus  <1=> 8-bit Multiplexed Bus
; <2=> 16-bit Demultiplexed Bus <3=> 16-bit Multiplexed Bus
_BTYP7     EQU    2     ; 0 = 8 bit Demultiplexed bus
                        ; 1 = 8 bit Multiplexed bus
                        ; 2 = 16 bit Demultiplexed bus
                        ; 3 = 16 bit Multiplexed bus
;</h>
;
; <h>TCONCS7: Definitions for the Timing Configuration register 
; =============================================================
;
; <o>PHA7: Phase A clock cycle (TCONCS7.0 .. TCONCS7.1) <0-3>
_PHA7       EQU    0    ; 0 = 0 clock cycles
                        ; : = : 
                        ; 3 = 3 clock cycles
;
; <o>PHB7: Phase B clock cycle (TCONCS7.2) <1-2> <#-1>
_PHB7       EQU    0    ; 0 = 1 clock cycle
                        ; 1 = 2 clock cycles
;
; <o>PHC7: Phase C clock cycle (TCONCS7.3 .. TCONCS7.4) <0-3>
_PHC7       EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o>PHD27 Phase D clock cycle (TCONCS2.5) <0-1>
_PHD7       EQU    0    ; 0 = 0 clock cycles
                        ; 1 = 1 clock cycle
;
; <o> PHE7: Phase E clock cycle (TCONCS7.6 .. TCONCS7.10) <1-32> <#-1>
_PHE7       EQU    8    ; 0 = 1 clock cycle
                        ; : = :
                        ; 31 = 32 clock cycles
;
; <o>RDPHF7: Phase F read clock cycle (TCONCS7.11 .. TCONCS7.12) <0-3>
_RDPHF7     EQU    0    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;
; <o>WRPHF7: Phase F write clock cycle (TCONCS7.13 .. TCONCS7.14) <0-3>
_WRPHF7     EQU    3    ; 0 = 0 clock cycles
                        ; : = :
                        ; 3 = 3 clock cycles
;</h> </e>
;
; </h>
; <<< end of configuration section >>>


$IF TINY
$SET (DPPUSE = 0)
$ENDIF


$IF NOT TINY
ASSUME  DPP3:SYSTEM
ASSUME  DPP2:NDATA
$ENDIF

NAME    ?C_STARTUP
PUBLIC  ?C_STARTUP
PUBLIC  ?L?VECSC

?L?VECSC        EQU     _VECSC   ; Interrupt Vector Spacing for L166

$IF MEDIUM OR LARGE OR HLARGE OR XLARGE
Model   LIT     'FAR'
$ELSE
Model   LIT     'NEAR'
$ENDIF

EXTRN   main:Model

PUBLIC          ?C_USRSTKBOT

?C_USERSTACK    SECTION DATA PUBLIC 'NDATA'
?C_USRSTKBOT:
                DS      USTSZ           ; Size of User Stack
?C_USERSTKTOP:
?C_USERSTACK    ENDS


IF UST1SZ > 0                           ; Define User Stack 1 area
?C_USERSTACK1   SECTION DATA PUBLIC 'NDATA'
?C_USRSTKBOT1:
                DS      UST1SZ          ; Size of User Stack 1
?C_USERSTKTOP1:
?C_USERSTACK1   ENDS
ENDIF

IF UST2SZ > 0                           ; Define User Stack 2 area
?C_USERSTACK2   SECTION DATA PUBLIC 'NDATA'
?C_USRSTKBOT2:
                DS      UST2SZ          ; Size of User Stack 2
?C_USERSTKTOP2:
?C_USERSTACK2   ENDS
ENDIF

$IF NOT TINY
IF (UST1SZ > 0) AND (UST2SZ > 0)        ; Define User Stack 1 area
NDATA           DGROUP  ?C_USERSTACK, ?C_USERSTACK1, ?C_USERSTACK2
ENDIF
IF (UST1SZ > 0) AND (UST2SZ = 0) 
NDATA           DGROUP  ?C_USERSTACK, ?C_USERSTACK1
ENDIF
IF (UST1SZ = 0) AND (UST2SZ > 0) 
NDATA           DGROUP  ?C_USERSTACK, ?C_USERSTACK2
ENDIF
IF (UST1SZ = 0) AND (UST2SZ = 0) 
NDATA           DGROUP  ?C_USERSTACK
ENDIF
$ENDIF

?C_MAINREGISTERS        REGDEF  R0 - R15

?C_SYSSTACK     SECTION DATA PUBLIC 'IDATA'
$IF NOT TINY
SDATA           DGROUP  ?C_SYSSTACK
$ENDIF
_BOS:                                   ; bottom of system stack
                DS      SSTSZ           ; Size of User Stack
_TOS:                                   ; top of system stack
?C_SYSSTACK     ENDS


PUBLIC          ?C_SYSSTKBOT
PUBLIC          ?C_SYSSTKTOP

?C_SYSSTKBOT    EQU     _BOS
?C_SYSSTKTOP    EQU     _TOS

                SSKDEF  7               ; unlimited System stack size

?C_STARTUP_CODE SECTION CODE    'ICODE'


;------------------------------------------------------------------------------

; Special Function Register Addresses
ADDRSEL1  EQU    0EE1EH
ADDRSEL2  EQU    0EE26H
ADDRSEL3  EQU    0EE2EH
ADDRSEL4  EQU    0EE36H
ADDRSEL7  EQU    0EE4EH
CPUCON1   DEFR   0FE18H
CPUCON2   DEFR   0FE1AH
EBCMOD0   EQU    0EE00H
EBCMOD1   EQU    0EE02H
FCONCS0   EQU    0EE12H
FCONCS1   EQU    0EE1AH
FCONCS2   EQU    0EE22H
FCONCS3   EQU    0EE2AH
FCONCS4   EQU    0EE32H
FCONCS7   EQU    0EE4AH
RSTCON    EQU    0F1E0H
SP        DEFR   0FE12H
SPSEG     DEFR   0FF0CH
STKOV     DEFR   0FE14H
STKUN     DEFR   0FE16H
SYSCON0   DEFR   0FF4AH
TCONCS0   EQU    0EE10H
TCONCS1   EQU    0EE18H
TCONCS2   EQU    0EE20H
TCONCS3   EQU    0EE28H
TCONCS4   EQU    0EE30H
TCONCS7   EQU    0EE48H
WDTREL    DEFR   0F0C8H
WDTCS     DEFR   0F0C6H
WUOSCCON  DEFR   0F1AEH
HPOSCCON  DEFR   0F1B4H
PLLOSCCON DEFR   0F1B6H
PLLSTAT   DEFR   0F0BCH
PLLCON0   DEFR   0F1B8H
PLLCON1   DEFR   0F1BAH
PLLCON2   DEFR   0F1BCH
PLLCON3   DEFR   0F1BEH
IMBCTRL   EQU    0FFFF00H
IMBCTRH   EQU    0FFFF02H
ESRCFG0	  DEFR   0F100H
ESRCFG1	  DEFR   0F102H
ESRCFG2	  DEFR   0F104H
STATCLR1  DEFR   0F0E2H
PLLCON0_NACK   BIT PLLCON0.15
PLLCON1_PACK   BIT PLLCON1.15
PLLCON2_K1ACK  BIT PLLCON2.15
PLLCON3_K2ACK  BIT PLLCON3.15

; Macro for calculation of ADDRSEL values -------------

CALC_ADDRSEL     MACRO   sym, adr, size
IF     size <= (4*KB)
sym             EQU     ((adr >> 8) AND 0xFFF0) OR 0
ELSEIF size <= (8*KB)
sym             EQU     ((adr >> 8) AND 0xFFE0) OR 1
ELSEIF size <= (16*KB)
sym             EQU     ((adr >> 8) AND 0xFFC0) OR 2
ELSEIF size <= (32*KB)
sym             EQU     ((adr >> 8) AND 0xFF80) OR 3
ELSEIF size <= (64*KB)
sym             EQU     ((adr >> 8) AND 0xFF00) OR 4
ELSEIF size <= (128*KB)
sym             EQU     ((adr >> 8) AND 0xFE00) OR 5
ELSEIF size <= (256*KB)
sym             EQU     ((adr >> 8) AND 0xFC00) OR 6
ELSEIF size <= (512*KB)
sym             EQU     ((adr >> 8) AND 0xF800) OR 7
ELSEIF size <= (1*MB)
sym             EQU     ((adr >> 8) AND 0xF000) OR 8
ELSEIF size <= (2*MB)
sym             EQU     ((adr >> 8) AND 0xE000) OR 9
ELSEIF size <= (4*MB)
sym             EQU     ((adr >> 8) AND 0xC000) OR 10
ELSEIF size <= (8*MB)
sym             EQU     ((adr >> 8) AND 0x8000) OR 11
ENDIF
                ENDM
; -----------------------------------------------------

?C_RESET        PROC TASK C_STARTUP INTNO RESET = 0
?C_STARTUP:     LABEL   Model

$IF (WATCHDOG = 0)
                DISWDT                  ; Disable watchdog timer
$ELSE 
                EXTR    #1
                MOV     WDTREL,#_WDTREL ; Set WDTREL register
_WDTCS          SET     (_IR<<8)
                EXTR    #1
                MOV     WDTCS,#_WDTCS   ; Set WDTCON register
                SRVWDT                  ; Enable watchdog
$ENDIF

                MOV     STKUN,#SOF (_TOS)       ; INITIALIZE STACK UNFL REGISTER
                MOV     STKOV,#SOF (_BOS+6*2)   ; INITIALIZE STACK OVFL REGISTER
                MOV     SP,#SOF (_TOS)          ; INITIALIZE STACK POINTER
                MOV     SPSEG,#SEG (_TOS)       ; INITIALIZE STACK POINTER SEGMENT

$IF (INIT_CPUCON1 = 1)                  ; Set CPUCON1 register
_CPC1           SET     (_VECSC<<5) OR (_WDTCTL<<4) OR (_SGTDIS<<3) 
_CPC1           SET     _CPC1 OR (_INTSCXT<<2) OR (_BP<<1) OR (_ZCJ)
                MOV     CPUCON1,#_CPC1
$ENDIF

$IF (INIT_CPUCON2 = 1)                  ; Set CPUCON2 register
_CPC2           SET     (_RETST<<3) OR (_DAID<<1) OR (_SL)
_CPC2           SET     _CPC2 OR (_EIOIAEN<<7) OR (_STEN<<6) OR (_LFIC<<5) OR (_OVRUN<<4)
_CPC2           SET     _CPC2 OR (_BYPPF<<9) OR (_BYPF<<8) 
_CPC2           SET     _CPC2 OR (_FIFODEPTH<<12) OR (_FIFOFED<<10) 
                MOV     CPUCON2,#_CPC2
$ENDIF

$IF (INIT_IMBCTR = 1)                   ; Set IMBCTR register
_IMBCTRL        EQU     (_DDF<<14) OR (_DCF<<12) OR (_DLCPF<<3) OR (_WSFLASH)
                MOV     R0,#_IMBCTRL
                EXTS    #SEG(IMBCTRL),#01H
                MOV     SOF(IMBCTRL),R0

_IMBCTRH        EQU     (_PSPROT<<84)
                MOV     R0,#_IMBCTRH
                EXTS    #SEG(IMBCTRH),#01H
                MOV     SOF(IMBCTRH),R0
$ENDIF

$IF (INIT_SYSCON0 = 1)                  ; Set SYSCON0 register
_SYSCON0        SET     (_EMCLKSELEN<<6) OR (_EMCLKSEL<<3) OR (_CLKSEL)
                MOV     SYSCON0,#_SYSCON0
$ENDIF


$IF (CONFIG_EBC = 1)                    ; Set EBCMOD0 register
_EBC0           SET     (_SLAVE<<9) OR (_ARBEN<<8) OR (_CSPEN<<4) OR (_SAPEN)
_EBC0           SET     _EBC0 OR (_BYTDIS<<12) OR (_WRCFG<<11)  OR (_EBCDIS<<10) 
_EBC0           SET     _EBC0 OR (_RDYPOL<<15) OR (_RDYDIS<<14) OR (_ALEDIS<<13)
                MOV     R0,#_EBC0
                MOV     EBCMOD0,R0

                                        ; Set EBCMOD1 register
_EBC1           SET     (_DHPDIS<<6) OR (_ALPDIS<<5) OR (_A0PDIS<<4) OR (_APDIS)
_EBC1           SET     _EBC1 OR (_WRPDIS<<7)
                MOV     R0,#_EBC1
                MOV     EBCMOD1,R0
$ENDIF

$IF (CONFIG_CS0)  
                                        ; Set TCONCS0 register
_TCS0           SET     (_PHD0<<5) OR (_PHC0<<3) OR (_PHB0<<2) OR (_PHA0)
_TCS0           SET     _TCS0 OR (_WRPHF0<<13) OR (_RDPHF0<<11) OR (_PHE0<<6)
                MOV     R0,#_TCS0
                MOV     TCONCS0,R0
                                        ; Set FCONCS0 register
_FCS0  SET  (_BTYP0<<4) OR (_RDYMOD0<<2) OR (_RDYEN0<<1) OR (_ENCS0)
                MOV     R0,#_FCS0
                MOV     FCONCS0,R0
$ENDIF

$IF (CONFIG_CS1)  
                                        ; Set TCONCS1 register
_TCS1           SET     (_PHD1<<5) OR (_PHC1<<3) OR (_PHB1<<2) OR (_PHA1)
_TCS1           SET     _TCS1 OR (_WRPHF1<<13) OR (_RDPHF1<<11) OR (_PHE1<<6)
                MOV     R0,#_TCS1
                MOV     TCONCS1,R0
                                        ; Set ADDRSEL1 register
CALC_ADDRSEL    _ADDRSEL1, _ADDR1, _SIZE1
                MOV     R0,#_ADDRSEL1
                MOV     ADDRSEL1,R0
                                        ; Set FCONCS1 register
_FCS1  SET  (_BTYP1<<4) OR (_RDYMOD1<<2) OR (_RDYEN1<<1) OR (_ENCS1)
                MOV     R0,#_FCS1
                MOV     FCONCS1,R0

$ENDIF

$IF (CONFIG_CS2)  
                                        ; Set TCONCS2 register
_TCS2           SET     (_PHD2<<5) OR (_PHC2<<3) OR (_PHB2<<2) OR (_PHA2)
_TCS2           SET     _TCS2 OR (_WRPHF2<<13) OR (_RDPHF2<<11) OR (_PHE2<<6)
                MOV     R0,#_TCS2
                MOV     TCONCS2,R0
                                        ; Set ADDRSEL2 register
CALC_ADDRSEL    _ADDRSEL2, _ADDR2, _SIZE2
                MOV     R0,#_ADDRSEL2
                MOV     ADDRSEL2,R0
                                        ; Set FCONCS2 register
_FCS2  SET  (_BTYP2<<4) OR (_RDYMOD2<<2) OR (_RDYEN2<<1) OR (_ENCS2)
                MOV     R0,#_FCS2
                MOV     FCONCS2,R0

$ENDIF

$IF (CONFIG_CS3)  
                                        ; Set TCONCS3 register
_TCS3           SET     (_PHD3<<5) OR (_PHC3<<3) OR (_PHB3<<2) OR (_PHA3)
_TCS3           SET     _TCS3 OR (_WRPHF3<<13) OR (_RDPHF3<<11) OR (_PHE3<<6)
                MOV     R0,#_TCS3
                MOV     TCONCS3,R0
                                        ; Set ADDRSEL3 register
CALC_ADDRSEL    _ADDRSEL3, _ADDR3, _SIZE3
                MOV     R0,#_ADDRSEL3
                MOV     ADDRSEL3,R0
                                        ; Set FCONCS3 register
_FCS3  SET  (_BTYP3<<4) OR (_RDYMOD3<<2) OR (_RDYEN3<<1) OR (_ENCS3)
                MOV     R0,#_FCS3
                MOV     FCONCS3,R0

$ENDIF

$IF (CONFIG_CS4)  
                                        ; Set TCONCS4 register
_TCS4           SET     (_PHD4<<5) OR (_PHC4<<3) OR (_PHB4<<2) OR (_PHA4)
_TCS4           SET     _TCS4 OR (_WRPHF4<<13) OR (_RDPHF4<<11) OR (_PHE4<<6)
                MOV     R0,#_TCS4
                MOV     TCONCS4,R0
                                        ; Set ADDRSEL4 register
CALC_ADDRSEL    _ADDRSEL4, _ADDR4, _SIZE4
                MOV     R0,#_ADDRSEL4
                MOV     ADDRSEL4,R0
                                        ; Set FCONCS4 register
_FCS4  SET  (_BTYP4<<4) OR (_RDYMOD4<<2) OR (_RDYEN4<<1) OR (_ENCS4)
                MOV     R0,#_FCS4
                MOV     FCONCS4,R0

$ENDIF

$IF (CONFIG_CS7)  
                                        ; Set TCONCS7 register
_TCS7           SET     (_PHD7<<5) OR (_PHC7<<3) OR (_PHB7<<2) OR (_PHA7)
_TCS7           SET     _TCS7 OR (_WRPHF7<<13) OR (_RDPHF7<<11) OR (_PHE7<<6)
                MOV     R0,#_TCS7
                MOV     TCONCS7,R0
                                        ; Set ADDRSEL7 register
CALC_ADDRSEL    _ADDRSEL7, _ADDR7, _SIZE7
                MOV     R0,#_ADDRSEL7
                MOV     ADDRSEL7,R0
                                        ; Set FCONCS7 register
_FCS7  SET  (_BTYP7<<4) OR (_RDYMOD7<<2) OR (_RDYEN7<<1) OR (_ENCS7)
                MOV     R0,#_FCS7 
                MOV     FCONCS7,R0

$ENDIF

$IF (INIT_RSTCON = 1)                   ; Set RSTCON register
_RSTCON         SET     (_ROCOFF<<5) OR (_RORMV<<4) OR (_RSTLEN)
_RSTCON         SET     _RSTCON OR (_RODIS<<7) OR (_ROCON<<6)
                MOV     R0,#_RSTCON
                MOV     RSTCON,R0
$ENDIF

$IF (INIT_WUOSCCON = 1)                 ; Set WUOSCCON register
_WUOSCCON       SET     (_DIS<<4) OR (_PWSEL<<2) OR (_FREQSEL)
                EXTR    #01H            ; Extended SFR access
                MOV     WUOSCCON,#_WUOSCCON
$ENDIF

$IF (INIT_HPOSCCON = 1)                 ; Set HPOSCCON register
_HPOSCCON       SET     (_X1DEN<<7) OR (_MODE<<2) OR (_OSCWDTRST<<1)
_HPOSCCON       SET     _HPOSCCON OR (_HP_EMFINDISEN<<10) OR (_HP_EMCLKEN<<9) OR (_SHBY<<8)
                EXTR    #01H            ; Extended SFR access
                MOV     HPOSCCON,#_HPOSCCON
$IF (_MODE = 0)
                NOP
; wait until OSC_HP frequency is usable
WHPO:           EXTR    #01H            ; Extended SFR access
                MOV     R0,HPOSCCON
                JNB     R0.0,WHPO       ; check PLLV
                EXTR    #01H            ; Extended SFR access
                MOV     STATCLR1,#04H   ; Clear HPOSCCON.OSC2L1
                CALL    Delay1ms        ; delay of at least 1ms when CPU is clocked with max. 10 MHz

$IF (MR_P = 1)                          ; new XC2xxxM/X/A devices have a flag which tells if the HPosc is stable
                EXTR    #01H            ; Extended SFR access
                MOV     R0,#PLLSTAT
                JNB     R0.15,WHPO      ; if PLLSTAT.OSCLOCK is not set -> retry to start HPOsc
$ENDIF ;$IF (MR_P = 1)

                EXTR    #01H            ; Extended SFR access
                MOV     R0,HPOSCCON
                JB      R0.11,WHPO      ; if HPOSCCON.OSC2L1 is set -> retry to start HPOsc
$ENDIF ;$IF (_MODE = 0)
$ENDIF ;$IF (INIT_HPOSCCON = 1)

$IF (INIT_PLLOSCCON = 1)                ; Set PLLOSCCON register
_PLLOSCCON      SET     (_OSCPD)
                EXTR    #01H            ; Extended SFR access
                BFLDL   PLLOSCCON,#01H,#_PLLOSCCON 
$ENDIF

$IF (INIT_PLLCON = 1)                   ; Set PLLCON registers

IF (NOT _VCOBY)                         ; if bypass mode is not selected
                MOV     R0,#00          ; make sure that the following PLL init code does not run too slow
ELSE
                MOV     R0,#_K1DIV      ; set K1 divider
ENDIF ; IF (NOT _VCOBY)
                CALL    ApplyNewK1Div

; switch to bypass mode before changing the clock source or VCO parameter
                EXTR    #01H            ; Extended SFR access
                OR      PLLCON0,#0001H  ; set bypass mode
                NOP
WBY:            EXTR    #01H            ; Extended SFR access
                MOV     R0,PLLSTAT
                JB      R0.0,WBY        ; wait until bypass mode active
                NOP

IF (_VCOSEL)                            ; if VCOSEL should be set
                EXTR    #01H            ; Extended SFR access
                OR      PLLCON0,#(_VCOSEL<<2) ; Set VCOSEL
                CALL    Delay200us      ; delay of at least 200us when CPU is clocked with max. 5 MHz
ENDIF

; select oscillator, set PDIV and enable P acknowledge
_PLLCON1        SET     (_PLL_EMCLKEN<<5) OR (_AOSCSEL<<3) OR (_OSCSEL<<1) OR (_PLLPWD)
_PLLCON1        SET     _PLLCON1 OR (_PDIV<<8) OR (_PLL_EMFINDISEN<<6)
                MOV     R0,#_PLLCON1
                CALL    ApplyNewPDiv

; keep VCO bypass, set VCOSEL, set NDIV and enable N acknowledge
_PLLCON0        SET     (_NDIV<<8) OR (_INSEL<<6) OR (_REGENSET<<5) OR (_REGENCLR<<4) OR (_VCOSEL<<2) OR (_VCOPWD<<1) OR (1)
                MOV     R0,#_PLLCON0
                CALL    ApplyNewNDiv

; set K2DIV so that fpll is not too different when disabling the bypass mode
_TMP_K2DIV      SET     15               ; K2DIV=15 will result in fvco < 10MHz
                MOV     R0,#_TMP_K2DIV
                CALL    ApplyNewK2Div


IF (NOT _VCOBY)  ; if bypass mode is not selected, check VCO and leave bypass mode
; restart VCO lock detection
                EXTR    #01H            ; Extended SFR access
                OR      PLLCON1,#0x0004 ; PLLCON1.RESLD = 1
; wait until VCO lock status is OK
WLOK:           EXTR    #01H            ; Extended SFR access
                MOV     R0,PLLSTAT
                JNB     R0.3,WLOK       ; wait until PLLSTAT.VCOLOCK is set

                EXTR    #01H            ; Extended SFR access
                AND     PLLCON0,#0xFFFE ; VCOBY = 0
; wait until VCO bypass status is left
WNBY:           MOV     R0,PLLSTAT
                JNB     R0.0,WNBY

; set up right K1DIV here 
                MOV     R0,#_K1DIV
                CALL    ApplyNewK1Div

; approach final K2DIV in 3 steps
_TMP_K2DIV      SET     (_TMP_K2DIV + _K2DIV) / 2
                MOV     R0,#_TMP_K2DIV
                CALL    ApplyNewK2Div
_TMP_K2DIV      SET     (_TMP_K2DIV + _K2DIV) / 2
                MOV     R0,#_TMP_K2DIV
                CALL    ApplyNewK2Div
_TMP_K2DIV      SET     (_TMP_K2DIV + _K2DIV) / 2
                MOV     R0,#_TMP_K2DIV
                CALL    ApplyNewK2Div

ENDIF ; IF (NOT _VCOBY)

; set final K2DIV
                MOV     R0,#_K2DIV
                CALL    ApplyNewK2Div

$ENDIF ;$IF (INIT_PLLCON = 1)


$IF (INIT_ESRCFG = 1)                   ; Set ESRCFGx registers
                                        ; Set PC0 bit register
                MOV     R0,#_ESR_PC0
                MOV     ESRCFG0,R0		; Set ESRCFG0 register
                MOV     R0,#_ESR_PC1
                MOV     ESRCFG1,R0		; Set ESRCFG1 register
                MOV     R0,#_ESR_PC2
                MOV     ESRCFG2,R0		; Set ESRCFG2 register
$ENDIF ;$IF (INIT_ESRCFG = 1)

$IF NOT TINY

                EXTRN   ?C_PAGEDPP0 : DATA16
                EXTRN   ?C_PAGEDPP1 : DATA16
                EXTRN   ?C_PAGEDPP2 : DATA16

$IF (DPPUSE = 1)
                MOV     DPP0,#?C_PAGEDPP0       ; INIT DPP0 VALUE
$ENDIF
                MOV     DPP1,#?C_PAGEDPP1       ; DEFAULT NEAR CONST PAGE
                MOV     DPP2,#?C_PAGEDPP2       ; DEFAULT NEAR DATA  PAGE

$ENDIF

                MOV     CP,#?C_MAINREGISTERS

                EINIT


IF UST1SZ > 0
                BFLDH   PSW,#03H,#02H           ; select local bank 1
                MOV     R0,#?C_USERSTKTOP1
ENDIF

IF UST2SZ > 0
                BFLDH   PSW,#03H,#03H           ; select local bank 2
                MOV     R0,#?C_USERSTKTOP2
ENDIF

IF (UST1SZ > 0) OR (UST2SZ > 0)
                BFLDH   PSW,#03H,#00H           ; select global bank
ENDIF

                MOV     R0,#?C_USERSTKTOP

;------------------------------------------------------------------------------
;
; The following code is necessary to set RAM variables to 0 at start-up
; (RESET) of the C application program.
;

$IF (CLR_MEMORY = 1)

                EXTRN   ?C_CLRMEMSECSTART : WORD
Clr_Memory:
$IF TINY
                MOV     R8,#?C_CLRMEMSECSTART
                JMPR    cc_Z,EndClear

RepeatClear:
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                MOV     R5,#0
                MOV     R2,[R8+]    ; Count
                JMPR    cc_Z,EndClear
                MOV     R3,R2
                MOV     R4,[R8+]
                JBC     R2.14,ClearNear

ClearBit:       MOV     R3,R4
                SHR     R3,#3
                BCLR    R3.0
                ADD     R3,#0FD00H              ; START OF BIT SPACE
                MOV     R5,#1
                SHL     R5,R4
                CPL     R5
                AND     R5,[R3]
                MOV     [R3],R5
                ADD     R4,#1
                SUB     R2,#1
                JMPR    cc_NZ,ClearBit
                JMPR    cc_UC,RepeatClear

ClearNear:
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                MOVB    [R4],RL5
                ADD     R4,#1
                SUB     R2,#1
                JMPR    cc_NN,ClearNear
                JMPR    cc_UC,RepeatClear

$ELSE
                MOV     R9,#SEG (?C_CLRMEMSECSTART)
                MOV     R8,#SOF (?C_CLRMEMSECSTART)
                MOV     R1,R8           
                OR      R1,R9
                JMPR    cc_Z,EndClear

RepeatClear:
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                MOV     R5,#0
                EXTS    R9,#1
                MOV     R2,[R8+]    ; Count
                JMPR    cc_Z,EndClear
                MOV     R3,R2
                EXTS    R9,#1
                MOV     R4,[R8+]
                JBC     R2.14,ClearNear
                JBC     R2.15,ClearFar

ClearBit:       MOV     R3,R4
                SHR     R3,#3
                BCLR    R3.0
                ADD     R3,#0FD00H              ; START OF BIT SPACE
                MOV     R5,#1
                SHL     R5,R4
                CPL     R5
                AND     R5,[R3]
                MOV     [R3],R5
                ADD     R4,#1
                SUB     R2,#1
                JMPR    cc_NZ,ClearBit
                JMPR    cc_UC,RepeatClear

ClearFar:       EXTS    R9,#1
                MOV     R3,[R8+]
RepClearFar:
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                EXTP    R4,#1
                MOVB    [R3],RL5
                ADD     R3,#1
                ADDC    R4,#0
                OR      R3,#0C000H
                SUB     R2,#1
                JMPR    cc_NN,RepClearFar
                JMPR    cc_UC,RepeatClear

ClearNear:
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                MOVB    [R4],RL5
                ADD     R4,#1
                SUB     R2,#1
                JMPR    cc_NN,ClearNear
                JMPR    cc_UC,RepeatClear
$ENDIF

EndClear:

$ENDIF

;------------------------------------------------------------------------------
;
;  The following code is necessary, if the application program contains
;  initialized variables at file level.
;

$IF (INIT_VARS = 1) ; *********************************************************

                EXTRN   ?C_INITSECSTART : WORD
Init_Vars:
$IF TINY ; ********************************************************************
                MOV     R8,#?C_INITSECSTART
RepeatInit:     
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                MOV     R2,[R8+]
                JMPR    cc_Z,EndInit
                JBC     R2.15,InitBit
                MOV     R4,R2
                AND     R2,#3FFFH
                JMPR    cc_NZ,LenLoad
                MOV     R4,#0
                MOV     R2,[R8+]
LenLoad:        MOV     R3,[R8+]
CopyInitVal:    MOVB    [R3],[R8+]
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                ADD     R3,#1
                SUB     R2,#1
                JMPR    cc_NZ,CopyInitVal
                JNB     R8.0,RepeatInit
                ADD     R8,#1
                ADDC    R9,#0                   ; potential overflow
                JMPR    cc_UC,RepeatInit

InitBit:        MOVBZ   R3,RL2
                SHL     R3,#1
                OR      R3,#0FD00H              ; START OF BIT SPACE
                MOV     R4,#1
                MOVB    RL5,RH2
                SHL     R4,R5                   ; CALCULATE BIT MASK
                JB      R2.7,SetBit
                CPL     R4                      ; CLEAR BIT
                AND     R4,[R3]
                JMPR    cc_UC,StoreBit
SetBit:         OR      R4,[R3]                 ; SET BIT
StoreBit:       MOV     [R3],R4
                JMPR    cc_UC,RepeatInit

EndInit:

$ELSE ; $IF TINY **************************************************************
                MOV     R9,#SEG (?C_INITSECSTART)
                MOV     R8,#SOF (?C_INITSECSTART)
$IF (DPP3USE = 1) ; ***********************************************************
RepeatInit:     
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                MOV     DPP3,#3
                EXTS    R9,#1
                MOV     R2,[R8]
                JMPR    cc_Z,EndInit
                ADD     R8,#2
                ADDC    R9,#0
                JBC     R2.15,InitBit
                MOV     R4,R2
                AND     R2,#3FFFH
                JMPR    cc_NZ,LenLoad
                MOV     R4,#0
                EXTS    R9,#1
                MOV     R2,[R8]
                ADD     R8,#2
                ADDC    R9,#0
LenLoad:        EXTS    R9,#1
                MOV     R3,[R8]
                ADD     R8,#2
                ADDC    R9,#0
                JB      R4.14,CopyInitVal
                MOV     DPP3,R3
                EXTS    R9,#1
                MOV     R3,[R8]
                ADD     R8,#2
                ADDC    R9,#0
CopyInitVal:    EXTS    R9,#1
                MOVB    RL5,[R8]
                ADD     R8,#1
                ADDC    R9,#0
                MOVB    [R3],RL5
                ADD     R3,#1
                JB      R4.14,NoDPP3Adj
                JB      R3.14,NoDPP3Adj
                ADD     DPP3,#1
                OR      R3,#0C000H              ; SET DPP3 Bits 
NoDPP3Adj:      
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                SUB     R2,#1
                JMPR    cc_NZ,CopyInitVal
                JNB     R8.0,RepeatInit
                ADD     R8,#1
                ADDC    R9,#0                   ; potential overflow
                JMPR    cc_UC,RepeatInit

InitBit:        MOVBZ   R3,RL2
                SHL     R3,#1
                OR      R3,#0FD00H              ; START OF BIT SPACE
                MOV     R4,#1
                MOVB    RL5,RH2
                SHL     R4,R5                   ; CALCULATE BIT MASK
                JB      R2.7,SetBit
                CPL     R4                      ; CLEAR BIT
                AND     R4,[R3]
                JMPR    cc_UC,StoreBit
SetBit:         OR      R4,[R3]                 ; SET BIT
StoreBit:       MOV     [R3],R4
                JMPR    cc_UC,RepeatInit

$ELSE ; block IF (DPP3USE = 1) ************************************************
RepeatInit:       
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                EXTS    R9,#1
                MOV     R2,[R8]
                JMPR    cc_Z,EndInit
                ADD     R8,#2
                ADDC    R9,#0
                JBC     R2.15,InitBit
                MOV     R4,R2
                AND     R2,#3FFFH
                JMPR    cc_NZ,LenLoad
                MOV     R4,#0
                EXTS    R9,#1
                MOV     R2,[R8]
                ADD     R8,#2
                ADDC    R9,#0
LenLoad:        EXTS    R9,#1
                MOV     R3,[R8]
                ADD     R8,#2
                ADDC    R9,#0
                JB      R4.14,CopyNearVal
                MOV     R6,R3
                EXTS    R9,#1
                MOV     R3,[R8]
                ADD     R8,#2
                ADDC    R9,#0
CopyInitVal:    EXTS    R9,#1
                MOVB    RL5,[R8]
                ADD     R8,#1
                ADDC    R9,#0
                EXTP    R6,#1
                MOV     [R3],RL5
                ADD     R3,#1
                ADDC    R6,#0
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                SUB     R2,#1
                JMPR    cc_NZ,CopyInitVal
                JMPR    cc_UC,CopyInitDone


CopyNearVal:    EXTS    R9,#1
                MOVB    RL5,[R8]
                ADD     R8,#1
                ADDC    R9,#0
                MOVB    [R3],RL5
                ADD     R3,#1
$IF (WATCHDOG = 1)
                SRVWDT                          ; SERVICE WATCHDOG
$ENDIF
                SUB     R2,#1
                JMPR    cc_NZ,CopyNearVal
CopyInitDone:   JNB     R8.0,RepeatInit
                ADD     R8,#1
                ADDC    R9,#0                   ; potential overflow
                JMPR    cc_UC,RepeatInit

InitBit:        MOVBZ   R3,RL2
                SHL     R3,#1
                OR      R3,#0FD00H              ; START OF BIT SPACE
                MOV     R4,#1
                MOVB    RL5,RH2
                SHL     R4,R5                   ; CALCULATE BIT MASK
                JB      R2.7,SetBit
                CPL     R4                      ; CLEAR BIT
                AND     R4,[R3]
                JMPR    cc_UC,StoreBit
SetBit:         OR      R4,[R3]                 ; SET BIT
StoreBit:       MOV     [R3],R4
                JMPR    cc_UC,RepeatInit
$ENDIF ; close block IF (DPP3USE = 1) **************************************** 

EndInit:

$ENDIF ; close block $IF TINY ************************************************ 

$ENDIF ; close $IF (INIT_VARS = 1) ******************************************* 

;------------------------------------------------------------------------------

$IF TINY
                JMP     main
$ELSE
                JMP     FAR main
$ENDIF
?C_RESET        ENDP

?C_UTILFUNCS    PROC    NEAR

Delay1ms:       MOV     R0,#0F000H      ; this is a delay of at least 1ms when CPU is clocked with max. 10 MHz
Del1:           CMPD1   R0,#00000H
                JMPR    CC_NE,Del1
                RET

Delay200us:     MOV     R0,#01000H      ; delay of at least 200us when CPU is clocked with max. 5 MHz
Del2:           CMPD1   R0,#00000H
                JMPR    CC_NE,Del2
                RET

ApplyNewK1Div:  MOV     R1,PLLCON2      ; new K1DIV value must be in R0
                AND     R1,#03FFH       ; mask K1DIV
                CMP     R0,R1           ; compare old and new value
                JMPR    cc_EQ,K1DivDone ; do nothing if identical

                MOV     PLLCON2,R0      ; set new K1DIV value without setting K1ACK

K1CLRLoop:      MOV     R1,PLLSTAT      ; read PLLSTAT
                JB      R1.7,K1CLRLoop  ; wait until K1RDY is clear
                
                EXTR    #01H            ; Extended SFR access
                BSET    PLLCON2_K1ACK   ; set K1ACK
K1SETLoop:      MOV     R1,PLLSTAT      ; read PLLSTAT
                JNB     R1.7,K1SETLoop  ; wait until K1RDY is set

K1DivDone:      RET


ApplyNewK2Div:  MOV     R1,PLLCON3      ; new K2DIV value must be in R0
                AND     R1,#03FFH       ; mask K2DIV
                CMP     R0,R1           ; compare old and new value
                JMPR    cc_EQ,K2DivDone ; do nothing if identical

                MOV     PLLCON3,R0      ; set new K2DIV value without setting K2ACK

K2CLRLoop:      MOV     R1,PLLSTAT      ; read PLLSTAT
                JB      R1.8,K2CLRLoop  ; wait until K2RDY is clear
                
                EXTR    #01H            ; Extended SFR access
                BSET    PLLCON3_K2ACK   ; set K2ACK

K2SETLoop:      MOV     R1,PLLSTAT      ; read PLLSTAT
                JNB     R1.8,K2SETLoop  ; wait until K2RDY is set

K2DivDone:      RET


ApplyNewPDiv:   MOV     R1,PLLCON1      ; new PLLCON1 value must be in R0
                XOR     R1,R0
                AND     R1,#0F00H
                CMP     R1,#00          ; check if PDIV needs to be modified
                JMPR    cc_NE,AppPDiv
                MOV     PLLCON1,R0      ; if PDIV is identical, just write PLLCON1
                RET

AppPDiv:        EXTR    #01H            ; Extended SFR access
                MOV     STATCLR1,#0003H ; Clear PLLSTAT.VCOL0/VCOL1
                MOV     PLLCON1,R0      ; write PLLCON1 (without PACK)
PCLRLoop:       MOV     R1,PLLSTAT      ; read PLLSTAT
                JB      R1.5,PCLRLoop   ; wait until PRDY is clear
                EXTR    #01H            ; Extended SFR access
                BSET    PLLCON1_PACK    ; set PACK
PSETLoop:       MOV     R1,PLLSTAT      ; read PLLSTAT
                JNB     R1.5,PSETLoop   ; wait until PRDY is set
                RET


ApplyNewNDiv:   MOV     R1,PLLCON0      ; new PLLCON0 value must be in R0
                XOR     R1,R0
                AND     R1,#3F00H
                CMP     R1,#00          ; check if NDIV needs to be modified
                JMPR    cc_NE,AppNDiv
                MOV     PLLCON0,R0      ; if NDIV is identical, just write PLLCON0
                RET

AppNDiv:        EXTR    #01H            ; Extended SFR access
                MOV     STATCLR1,#03H   ; Clear PLLSTAT.VCOL0/VCOL1
                MOV     PLLCON0,R0      ; write PLLCON0 (without NACK)
NCLRLoop:       MOV     R1,PLLSTAT      ; read PLLSTAT
                JB      R1.6,NCLRLoop   ; wait until NRDY is clear
                EXTR    #01H            ; Extended SFR access
                BSET    PLLCON0_NACK    ; set NACK
NSETLoop:       MOV     R1,PLLSTAT      ; read PLLSTAT
                JNB     R1.6,NSETLoop   ; wait until NRDY is set
                RET


?C_UTILFUNCS    ENDP

?C_STARTUP_CODE ENDS

$IF (INIT_VARS = 1)
EXTERN  ?C_ENDINIT:WORD
$ENDIF

                END



